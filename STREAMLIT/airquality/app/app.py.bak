#!/usr/bin/env python3
"""
Application Streamlit - QualitÃ© de l'air gÃ©olocalisÃ©e
"""

import streamlit as st
import folium
from streamlit_folium import st_folium
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import os
import logging
from dotenv import load_dotenv
from pathlib import Path

# Charger les variables d'environnement depuis le bon emplacement
# Le .env est dans /STREAMLIT/.env (2 niveaux au-dessus : app -> airquality -> STREAMLIT)
env_path = Path(__file__).parent.parent / ".env"
if not env_path.exists():
    # Fallback : essayer un niveau de plus
    env_path = Path(__file__).parent.parent.parent / ".env"
load_dotenv(dotenv_path=env_path)

# Import forcÃ© du config local pour Ã©viter conflit avec Image-Analysis
import sys
import importlib.util

# Charger le config.py LOCAL (pas celui de Image-Analysis)
_config_path = Path(__file__).parent / "config.py"
_spec = importlib.util.spec_from_file_location("app_config", _config_path)
_config_module = importlib.util.module_from_spec(_spec)
_spec.loader.exec_module(_config_module)

# Importer les fonctions depuis le module chargÃ©
download_air_quality_data = _config_module.download_air_quality_data
geocode_address = _config_module.geocode_address
get_sample_data = _config_module.get_sample_data
get_last_address = _config_module.get_last_address
DB_PATH = _config_module.DB_PATH

from db_utils import AirQualityDB, WeatherDB, DatabaseManager
from air_quality_map import AirQualityMapper
from auth import require_auth
from weather_ui import download_weather_data
from results_ui import display_results
from environment_downloader import EnvironmentDownloader

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def download_environment_data_auto(address: str, lat: float, lon: float) -> bool:
    """
    TÃ©lÃ©charge automatiquement les cartes satellites et Street View
    avec les options par dÃ©faut lors du clic sur "Analyser"
    
    Args:
        address: Adresse de la localisation
        lat: Latitude
        lon: Longitude
    
    Returns:
        True si succÃ¨s
    """
    try:
        downloader = EnvironmentDownloader(address)
        downloader.lat = lat
        downloader.lon = lon
        downloader.formatted_address = address
        
        logger.info(f"ğŸ—ºï¸ TÃ©lÃ©chargement automatique des cartes pour: {address}")
        
        # Configuration par dÃ©faut pour les satellites (plus conservatrice)
        satellite_config = {
            'radius_km': 0.5,  # Rayon rÃ©duit pour sÃ©curitÃ©
            'zoom_levels': [17, 18],  # 2 niveaux seulement
            'map_types': ['satellite', 'roadmap']
        }
        
        # Configuration par dÃ©faut pour Street View
        streetview_config = {
            'radius_m': 250,
            'max_photos': 12,
            'use_smart_filter': True
        }
        
        with st.spinner("ğŸ›°ï¸ TÃ©lÃ©chargement des cartes satellites..."):
            try:
                sat_metadata = downloader.download_satellite_maps(**satellite_config)
                logger.info(f"âœ… Cartes satellites tÃ©lÃ©chargÃ©es: {sat_metadata['total_images']} images")
            except Exception as e:
                logger.warning(f"âš ï¸ Erreur satellites (ignorÃ©e): {e}")
                st.warning("âš ï¸ Cartes satellites non disponibles (continuons...)")
        
        with st.spinner("ğŸ“¸ TÃ©lÃ©chargement des images Street View..."):
            try:
                sv_metadata = downloader.download_streetview_images(**streetview_config)
                logger.info(f"âœ… Street View tÃ©lÃ©chargÃ©: {sv_metadata['total_photos']} photos")
            except Exception as e:
                logger.warning(f"âš ï¸ Erreur Street View (ignorÃ©e): {e}")
                st.warning("âš ï¸ Images Street View non disponibles (continuons...)")
        
        st.success("âœ… Cartes environnementales tÃ©lÃ©chargÃ©es")
        return True
        
    except Exception as e:
        logger.error(f"âŒ Erreur tÃ©lÃ©chargement cartes: {e}")
        st.warning("âš ï¸ Module cartes temporairement indisponible")
        return False


# Configuration de la page
st.set_page_config(
    page_title="QualitÃ© de l'Air & MÃ©tÃ©o - Bruxelles",
    page_icon="ğŸŒ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Style CSS personnalisÃ©
st.markdown("""
    <style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
    }
    </style>
""", unsafe_allow_html=True)

# Initialisation de la session
if 'data_loaded' not in st.session_state:
    st.session_state.data_loaded = False
if 'current_address' not in st.session_state:
    st.session_state.current_address = None
if 'geocode_results' not in st.session_state:
    st.session_state.geocode_results = None
if 'use_manual' not in st.session_state:
    st.session_state.use_manual = False
if 'manual_lat' not in st.session_state:
    st.session_state.manual_lat = 50.8503
if 'manual_lon' not in st.session_state:
    st.session_state.manual_lon = 4.3517
if 'manual_address' not in st.session_state:
    st.session_state.manual_address = ""
if 'selected_db' not in st.session_state:
    st.session_state.selected_db = None

# Fonction principale - DOIT ÃŠTRE APPELÃ‰E EN PREMIER
def main():
    """Fonction principale de l'application"""
    logger.info("=== Demarrage de l'application ===")
    
    # Protection par authentification
    require_auth()
    
    # En-tÃªte
    st.markdown('<div class="main-header">ğŸŒ QualitÃ© de l\'Air & MÃ©tÃ©o - Analyse GÃ©olocalisÃ©e</div>', unsafe_allow_html=True)

    # Si une base est dÃ©jÃ  chargÃ©e, afficher un bandeau d'info
    if st.session_state.data_loaded and st.session_state.current_address:
        col1, col2 = st.columns([4, 1])
        with col1:
            db_name = st.session_state.selected_db if st.session_state.selected_db else "Base par dÃ©faut"
            
            # RÃ©cupÃ©rer l'intervalle de dates
            try:
                if st.session_state.selected_db:
                    db = AirQualityDB(address=st.session_state.current_address)
                    db.db_path = st.session_state.selected_db
                else:
                    db = AirQualityDB(address=st.session_state.current_address)
                
                date_range = db.get_date_range(st.session_state.current_address)
                
                if date_range and date_range['start_date'] and date_range['end_date']:
                    start = pd.to_datetime(date_range['start_date']).strftime('%d/%m/%Y %H:%M')
                    end = pd.to_datetime(date_range['end_date']).strftime('%d/%m/%Y %H:%M')
                    st.success(f"ğŸ“Š Analyse active : **{st.session_state.current_address}**\n\nğŸ“… PÃ©riode : `{start}` â†’ `{end}` | Base : `{os.path.basename(db_name)}`")
                else:
                    st.success(f"ğŸ“Š Analyse active : **{st.session_state.current_address}** | Base : `{os.path.basename(db_name)}`")
            except Exception as e:
                logger.error(f"Erreur rÃ©cupÃ©ration dates: {e}")
                st.success(f"ğŸ“Š Analyse active : **{st.session_state.current_address}** | Base : `{os.path.basename(db_name)}`")
        
        with col2:
            if st.button("ğŸ”„ Nouvelle analyse"):
                st.session_state.data_loaded = False
                st.session_state.current_address = None
                st.session_state.selected_db = None
                st.rerun()

    # VÃ©rifier si des donnÃ©es existent dÃ©jÃ  
    elif os.path.exists(DB_PATH) and not st.session_state.data_loaded:
        last_address = get_last_address()
        if last_address:
            st.info(f"ğŸ“Š DonnÃ©es existantes dÃ©tectÃ©es pour : **{last_address}**")
            col1, col2 = st.columns([1, 3])
            with col1:
                if st.button("ğŸ“‚ Charger ces donnÃ©es"):
                    st.session_state.data_loaded = True
                    st.session_state.current_address = last_address
                    st.rerun()
            with col2:
                st.caption("Ou entrez une nouvelle adresse dans la barre latÃ©rale ğŸ‘ˆ")
    elif not st.session_state.data_loaded:
        # Message de dÃ©marrage simple
        st.info("ğŸ‘‹ Entrez une adresse dans la barre latÃ©rale pour commencer l'analyse")
    
    # Sidebar
    with st.sidebar:
        st.header("ğŸ¯ Configuration")
        
        # Choix du mode de saisie
        input_mode = st.radio(
            "Mode de saisie",
            ["ğŸ” Par adresse", "ğŸ” CoordonnÃ©es manuelles"],
            label_visibility="collapsed"
        )
        
        address_input = None  # Initialiser par dÃ©faut
        
        if input_mode == "ğŸ” Par adresse":
            address_input = st.text_input(
                "ğŸ” Entrez votre adresse",
                placeholder="Ex: Avenue Louise, Bruxelles",
                help="Soyez prÃ©cis pour de meilleurs rÃ©sultats"
            )
            
            # Si on a des rÃ©sultats multiples, les afficher
            if 'geocode_results' in st.session_state and st.session_state.geocode_results:
                st.warning("ğŸ” Plusieurs rÃ©sultats trouvÃ©s. Choisissez :")
                
                options = []
                for i, loc in enumerate(st.session_state.geocode_results[:5]):
                    label = f"{loc['name']}, {loc.get('admin1', '')}, {loc.get('country', '')} ({loc['latitude']:.4f}, {loc['longitude']:.4f})"
                    options.append(label)
                
                selected = st.selectbox("SÃ©lectionnez votre localisation", options)
                
                if st.button("âœ… Confirmer la sÃ©lection", type="primary"):
                    idx = options.index(selected)
                    loc = st.session_state.geocode_results[idx]
                    st.session_state.manual_lat = loc['latitude']
                    st.session_state.manual_lon = loc['longitude']
                    st.session_state.manual_address = f"{loc['name']}, {loc.get('admin1', '')}, {loc.get('country', '')}"
                    st.session_state.geocode_results = None
                    st.session_state.use_manual = True
                    st.rerun()
        
        else:
            # Mode coordonnÃ©es manuelles
            st.info("ğŸ“ Entrez les coordonnÃ©es (format dÃ©cimal)")
            manual_lat = st.number_input("Latitude", min_value=-90.0, max_value=90.0, value=50.8503, step=0.0001, format="%.6f")
            manual_lon = st.number_input("Longitude", min_value=-180.0, max_value=180.0, value=4.3517, step=0.0001, format="%.6f")
            manual_address_name = st.text_input("Nom du lieu (optionnel)", value="Bruxelles")
            
            if st.button("âœ… Utiliser ces coordonnÃ©es", type="primary"):
                st.session_state.manual_lat = manual_lat
                st.session_state.manual_lon = manual_lon
                st.session_state.manual_address = manual_address_name or f"Point ({manual_lat:.4f}, {manual_lon:.4f})"
                st.session_state.use_manual = True
        
        date_range = st.date_input(
            "ğŸ“… PÃ©riode d'analyse",
            value=(datetime(2025, 10, 1), datetime(2025, 10, 16)),
            help="SÃ©lectionnez la pÃ©riode de donnÃ©es"
        )
        
        search_button = st.button("ğŸ” Analyser", type="primary", use_container_width=True)
        
        st.divider()
        
        # Options avancÃ©es
        with st.expander("âš™ï¸ Options avancÃ©es"):
            auto_refresh = st.checkbox("RafraÃ®chir automatiquement les donnÃ©es", value=False)
            st.session_state.show_raw_data = st.checkbox("Afficher les donnÃ©es brutes", value=False)
        
        # Gestion de la base de donnÃ©es
        st.divider()
        st.subheader("ğŸ—„ï¸ Bases de donnÃ©es")
        
        # Lister toutes les bases disponibles
        available_dbs = DatabaseManager.list_all_databases('air_quality')
        
        if available_dbs:
            st.success(f"âœ… {len(available_dbs)} base(s) disponible(s)")
            
            # SÃ©lecteur de bases de donnÃ©es
            with st.expander("ğŸ“‚ Charger une base existante", expanded=False):
                st.caption("SÃ©lectionnez une base de donnÃ©es historique Ã  analyser")
                
                for idx, db_info in enumerate(available_dbs):
                    col1, col2 = st.columns([3, 1])
                    
                    with col1:
                        st.write(f"**{db_info['address'].replace('_', ' ').title()}**")
                        st.caption(f"ğŸ“… {db_info['date_range']}")
                        st.caption(f"ğŸ“Š {db_info['records']} enregistrements â€¢ {db_info['size']:.2f} MB")
                        st.caption(f"ğŸ•’ ModifiÃ©: {db_info['modified'].strftime('%d/%m/%Y %H:%M')}")
                    
                    with col2:
                        if st.button("ğŸ“¥ Charger", key=f"load_db_{idx}"):
                            st.session_state.selected_db = db_info['path']
                            st.session_state.current_address = db_info['address'].replace('_', ' ').title()
                            st.session_state.data_loaded = True
                            st.success(f"âœ… Base chargÃ©e: {db_info['path']}")
                            st.rerun()
                    
                    if idx < len(available_dbs) - 1:
                        st.divider()
            
            # Option de rÃ©initialisation (seulement pour DB_PATH par dÃ©faut)
            if os.path.exists(DB_PATH):
                with st.expander("âš ï¸ Options de maintenance"):
                    if st.button("ğŸ”„ RÃ©initialiser la base par dÃ©faut", type="secondary"):
                        try:
                            os.remove(DB_PATH)
                            st.session_state.data_loaded = False
                            st.session_state.current_address = None
                            st.session_state.selected_db = None
                            st.success("Base par dÃ©faut rÃ©initialisÃ©e !")
                            st.rerun()
                        except Exception as e:
                            st.error(f"Erreur : {e}")
        else:
            st.info("ğŸ”­ Aucune base de donnÃ©es disponible")
            st.caption("TÃ©lÃ©chargez des donnÃ©es pour une adresse pour crÃ©er votre premiÃ¨re base.")

    # === TRAITEMENT DES REQUÃŠTES ===
    
    # GÃ©rer les coordonnÃ©es manuelles
    if 'use_manual' in st.session_state and st.session_state.use_manual:
        logger.info(f"Recherche par coordonnees manuelles: {st.session_state.manual_address}")
        lat = st.session_state.manual_lat
        lon = st.session_state.manual_lon
        full_address = st.session_state.manual_address
        
        st.success(f"Coordonnees manuelles : {full_address}")
        st.info(f"Latitude: {lat:.6f}N, Longitude: {lon:.6f}E")
        st.markdown(f"[Verifier sur Google Maps](https://www.google.com/maps?q={lat},{lon})")
        
        # Telecharger les donnees
        with st.spinner("Telechargement des donnees..."):
            logger.info(f"Telechargement air quality pour: {full_address}")
            success, info = download_air_quality_data(
                lat, lon, full_address,
                date_range[0].strftime("%Y-%m-%d"),
                date_range[1].strftime("%Y-%m-%d")
            )
        
        if success and info:
            st.success(f"{info['records']} enregistrements telecharges")
            
            # Telecharger aussi la meteo
            download_weather_data(full_address, lat, lon)
            
            # Telecharger automatiquement les cartes satellites et Street View
            download_environment_data_auto(full_address, lat, lon)
            
            st.session_state.data_loaded = True
            st.session_state.current_address = full_address
            st.session_state.use_manual = False
            logger.info(f"Donnees chargees avec succes pour: {full_address}")
            st.rerun()
    
    # Gerer la recherche par adresse
    if search_button:
        logger.info(f"Recherche par adresse: {address_input}")
        if not address_input:
            st.warning("Veuillez entrer une adresse")
        else:
            with st.spinner("Geolocalisation en cours..."):
                result = geocode_address(address_input)
            
            # Gerer les resultats multiples
            if result == ("MULTIPLE_RESULTS", None, None):
                logger.info("Geocodage: plusieurs resultats - attente selection utilisateur")
                st.info("Plusieurs resultats trouves. Selectionnez votre localisation ci-dessus.")
            
            else:
                lat, lon, full_address = result
                
                if lat and lon:
                    st.success(f"Adresse trouvee : {full_address}")
                    st.info(f"Coordonnees : {lat:.6f}N, {lon:.6f}E")
                    
                    # Afficher lien Google Maps
                    st.markdown(f"[Verifier sur Google Maps](https://www.google.com/maps?q={lat},{lon})")
                    
                    # Telecharger les donnees de qualite de l'air
                    with st.spinner("Telechargement des donnees de qualite de l'air..."):
                        logger.info(f"Telechargement air quality pour: {full_address}")
                        success, info = download_air_quality_data(
                            lat, lon, full_address,
                            date_range[0].strftime("%Y-%m-%d"),
                            date_range[1].strftime("%Y-%m-%d")
                        )
                    
                    if success and info:
                        st.success(f"{info['records']} enregistrements air quality telecharges")
                        
                        # Telecharger aussi la meteo
                        download_weather_data(full_address, lat, lon)
                        
                        # Telecharger automatiquement les cartes satellites et Street View
                        download_environment_data_auto(full_address, lat, lon)
                        
                        st.session_state.data_loaded = True
                        st.session_state.current_address = full_address
                        logger.info(f"Donnees chargees avec succes pour: {full_address}")
                        st.rerun()
                    else:
                        logger.error(f"Echec telechargement pour: {full_address}")
                else:
                    logger.warning(f"Adresse introuvable: {address_input}")
                    st.error("Adresse introuvable. Utilisez le mode 'Coordonnees manuelles' ci-dessus.")
    
    # Affichage des resultats si donnees chargees
    if st.session_state.data_loaded and st.session_state.current_address:
        logger.info(f"Affichage resultats pour: {st.session_state.current_address}")
        display_results(st.session_state.current_address)
    
    # Footer
    st.divider()
    st.markdown("""
        <div style='text-align: center; color: gray;'>
            DonnÃ©es fournies par Open-Meteo Air Quality API & Meteosource | 
            Application dÃ©veloppÃ©e avec Streamlit
        </div>
    """, unsafe_allow_html=True)


# Point d'entrÃ©e de l'application
if __name__ == "__main__":
    main()
